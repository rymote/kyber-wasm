import Kyber1024Module from './kyber1024_wasm.js';

/**
 * Kyber-1024 post-quantum key encapsulation mechanism
 * @class
 */
export class Kyber1024 {
  constructor() {
    this.module = null;
    this.ready = false;
  }

  /**
   * Initialize the WASM module
   * @async
   * @returns {Promise<void>}
   * @throws {Error} If module initialization fails
   */
  async init() {
    if (this.ready) return;
    
    this.module = await Kyber1024Module();
    
    if (typeof this.module._malloc !== 'function') {
      throw new Error('WASM module not properly initialized - malloc unavailable');
    }
    
    this.ready = true;
  }

  /**
   * Generate a keypair (random or deterministic)
   * @param {Uint8Array} [seed] - Optional 64-byte seed for deterministic generation
   * @returns {{ publicKey: Uint8Array, secretKey: Uint8Array }} Generated keypair
   * @throws {Error} If module not initialized or key generation fails
   * @example
   * // Random keypair
   * const { publicKey, secretKey } = kyber.keypair();
   * 
   * // Deterministic keypair
   * const seed = generateSeed(64);
   * const { publicKey, secretKey } = kyber.keypair(seed);
   */
  keypair(seed) {
    if (!this.ready) throw new Error('Module not initialized. Call init() first.');
    
    if (seed !== undefined) {
      if (!(seed instanceof Uint8Array) || seed.length !== 64) {
        throw new Error('Seed must be a Uint8Array of exactly 64 bytes (2 * KYBER_SYMBYTES).');
      }
      return this._keypairSeeded(seed);
    }
    
    return this._keypairRandom();
  }

  /**
   * Encapsulate a shared secret (random or deterministic)
   * @param {Uint8Array} publicKey - 1568-byte public key
   * @param {Uint8Array} [seed] - Optional 32-byte seed for deterministic encapsulation
   * @returns {{ ciphertext: Uint8Array, sharedSecret: Uint8Array }} Encapsulation result
   * @throws {Error} If invalid parameters or encapsulation fails
   * @example
   * // Random encapsulation
   * const { ciphertext, sharedSecret } = kyber.encapsulate(publicKey);
   * 
   * // Deterministic encapsulation
   * const seed = generateSeed(32);
   * const { ciphertext, sharedSecret } = kyber.encapsulate(publicKey, seed);
   */
  encapsulate(publicKey, seed) {
    if (!this.ready) throw new Error('Module not initialized. Call init() first.');
    if (!(publicKey instanceof Uint8Array) || publicKey.length !== 1568) {
      throw new Error('Invalid public key. Must be Uint8Array of 1568 bytes.');
    }
    
    if (seed !== undefined) {
      if (!(seed instanceof Uint8Array) || seed.length !== 32) {
        throw new Error('Seed must be a Uint8Array of exactly 32 bytes (KYBER_SYMBYTES).');
      }
      return this._encapsulateSeeded(publicKey, seed);
    }
    
    return this._encapsulateRandom(publicKey);
  }

  /**
   * Decapsulate a shared secret
   * @param {Uint8Array} ciphertext - 1568-byte ciphertext
   * @param {Uint8Array} secretKey - 3168-byte secret key
   * @returns {Uint8Array} 32-byte shared secret
   * @throws {Error} If invalid parameters or decapsulation fails
   * @example
   * const sharedSecret = kyber.decapsulate(ciphertext, secretKey);
   */
  decapsulate(ciphertext, secretKey) {
    if (!this.ready) throw new Error('Module not initialized. Call init() first.');
    if (!(ciphertext instanceof Uint8Array) || ciphertext.length !== 1568) {
      throw new Error('Invalid ciphertext. Must be Uint8Array of 1568 bytes.');
    }
    if (!(secretKey instanceof Uint8Array) || secretKey.length !== 3168) {
      throw new Error('Invalid secret key. Must be Uint8Array of 3168 bytes.');
    }
    
    const ctPtr = this.module._malloc(1568);
    const skPtr = this.module._malloc(3168);
    const ssPtr = this.module._malloc(32);
    
    try {
      this.module.writeArrayToMemory(ciphertext, ctPtr);
      this.module.writeArrayToMemory(secretKey, skPtr);
      
      const result = this.module._kyber1024_dec(ssPtr, ctPtr, skPtr);
      if (result !== 0) throw new Error('Decapsulation failed');
      
      const sharedSecret = new Uint8Array(32);
      for (let i = 0; i < 32; i++) {
        sharedSecret[i] = this.module.getValue(ssPtr + i, 'i8') & 0xFF;
      }
      return sharedSecret;
    } finally {
      this.module._free(ctPtr);
      this.module._free(skPtr);
      this.module._free(ssPtr);
    }
  }

  /**
   * Generate a random keypair (internal)
   * @private
   * @returns {{ publicKey: Uint8Array, secretKey: Uint8Array }}
   */
  _keypairRandom() {
    const pkPtr = this.module._malloc(1568);
    const skPtr = this.module._malloc(3168);
    
    try {
      const result = this.module._kyber1024_keypair(pkPtr, skPtr);
      if (result !== 0) throw new Error('Key generation failed');
      
      const publicKey = new Uint8Array(1568);
      const secretKey = new Uint8Array(3168);
      for (let i = 0; i < 1568; i++) {
        publicKey[i] = this.module.getValue(pkPtr + i, 'i8') & 0xFF;
      }
      for (let i = 0; i < 3168; i++) {
        secretKey[i] = this.module.getValue(skPtr + i, 'i8') & 0xFF;
      }
      
      return { publicKey, secretKey };
    } finally {
      this.module._free(pkPtr);
      this.module._free(skPtr);
    }
  }

  /**
   * Generate a deterministic keypair from seed (internal)
   * @private
   * @param {Uint8Array} seed - 64-byte seed
   * @returns {{ publicKey: Uint8Array, secretKey: Uint8Array }}
   */
  _keypairSeeded(seed) {
    const pkPtr = this.module._malloc(1568);
    const skPtr = this.module._malloc(3168);
    const seedPtr = this.module._malloc(64);
    
    try {
      this.module.writeArrayToMemory(seed, seedPtr);
      
      const result = this.module._kyber1024_keypair_seeded(pkPtr, skPtr, seedPtr);
      if (result !== 0) throw new Error('Seeded key generation failed');
      
      const publicKey = new Uint8Array(1568);
      const secretKey = new Uint8Array(3168);
      for (let i = 0; i < 1568; i++) {
        publicKey[i] = this.module.getValue(pkPtr + i, 'i8') & 0xFF;
      }
      for (let i = 0; i < 3168; i++) {
        secretKey[i] = this.module.getValue(skPtr + i, 'i8') & 0xFF;
      }
      
      return { publicKey, secretKey };
    } finally {
      this.module._free(pkPtr);
      this.module._free(skPtr);
      this.module._free(seedPtr);
    }
  }

  /**
   * Random encapsulation (internal)
   * @private
   * @param {Uint8Array} publicKey
   * @returns {{ ciphertext: Uint8Array, sharedSecret: Uint8Array }}
   */
  _encapsulateRandom(publicKey) {
    const pkPtr = this.module._malloc(1568);
    const ctPtr = this.module._malloc(1568);
    const ssPtr = this.module._malloc(32);
    
    try {
      this.module.writeArrayToMemory(publicKey, pkPtr);
      
      const result = this.module._kyber1024_enc(ctPtr, ssPtr, pkPtr);
      if (result !== 0) throw new Error('Encapsulation failed');
      
      const ciphertext = new Uint8Array(1568);
      const sharedSecret = new Uint8Array(32);
      for (let i = 0; i < 1568; i++) {
        ciphertext[i] = this.module.getValue(ctPtr + i, 'i8') & 0xFF;
      }
      for (let i = 0; i < 32; i++) {
        sharedSecret[i] = this.module.getValue(ssPtr + i, 'i8') & 0xFF;
      }
      
      return { ciphertext, sharedSecret };
    } finally {
      this.module._free(pkPtr);
      this.module._free(ctPtr);
      this.module._free(ssPtr);
    }
  }

  /**
   * Deterministic encapsulation with seed (internal)
   * @private
   * @param {Uint8Array} publicKey
   * @param {Uint8Array} seed - 32-byte seed
   * @returns {{ ciphertext: Uint8Array, sharedSecret: Uint8Array }}
   */
  _encapsulateSeeded(publicKey, seed) {
    const pkPtr = this.module._malloc(1568);
    const ctPtr = this.module._malloc(1568);
    const ssPtr = this.module._malloc(32);
    const seedPtr = this.module._malloc(32);
    
    try {
      this.module.writeArrayToMemory(publicKey, pkPtr);
      this.module.writeArrayToMemory(seed, seedPtr);
      
      const result = this.module._kyber1024_enc_seeded(ctPtr, ssPtr, pkPtr, seedPtr);
      if (result !== 0) throw new Error('Seeded encapsulation failed');
      
      const ciphertext = new Uint8Array(1568);
      const sharedSecret = new Uint8Array(32);
      for (let i = 0; i < 1568; i++) {
        ciphertext[i] = this.module.getValue(ctPtr + i, 'i8') & 0xFF;
      }
      for (let i = 0; i < 32; i++) {
        sharedSecret[i] = this.module.getValue(ssPtr + i, 'i8') & 0xFF;
      }
      
      return { ciphertext, sharedSecret };
    } finally {
      this.module._free(pkPtr);
      this.module._free(ctPtr);
      this.module._free(ssPtr);
      this.module._free(seedPtr);
    }
  }
}