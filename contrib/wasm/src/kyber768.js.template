import Kyber768Module from './kyber768_wasm.js';

export class Kyber768 {
  constructor() {
    this.module = null;
    this.ready = false;
  }

  async init() {
    if (this.ready) return;
    
    this.module = await Kyber768Module();
    
    if (typeof this.module._malloc !== 'function') {
      throw new Error('WASM module not properly initialized - malloc unavailable');
    }
    
    this.ready = true;
  }

  keypair() {
    if (!this.ready) throw new Error('Module not initialized. Call init() first.');
    
    const pkPtr = this.module._malloc(1184);
    const skPtr = this.module._malloc(2400);
    
    try {
      const result = this.module._kyber768_keypair(pkPtr, skPtr);
      if (result !== 0) throw new Error('Key generation failed');
      
      // Read data using getValue (convert signed to unsigned)
      const publicKey = new Uint8Array(1184);
      const secretKey = new Uint8Array(2400);
      for (let i = 0; i < 1184; i++) {
        publicKey[i] = this.module.getValue(pkPtr + i, 'i8') & 0xFF;
      }
      for (let i = 0; i < 2400; i++) {
        secretKey[i] = this.module.getValue(skPtr + i, 'i8') & 0xFF;
      }
      
      return { publicKey, secretKey };
    } finally {
      this.module._free(pkPtr);
      this.module._free(skPtr);
    }
  }

  encapsulate(publicKey) {
    if (!this.ready) throw new Error('Module not initialized. Call init() first.');
    if (!(publicKey instanceof Uint8Array)) throw new Error('Public key must be Uint8Array');
    if (publicKey.length !== 1184) throw new Error('Invalid public key length. Expected 1184 bytes.');
    
    const pkPtr = this.module._malloc(1184);
    const ctPtr = this.module._malloc(1088);
    const ssPtr = this.module._malloc(32);
    
    try {
      // Write public key using writeArrayToMemory
      this.module.writeArrayToMemory(publicKey, pkPtr);
      
      const result = this.module._kyber768_enc(ctPtr, ssPtr, pkPtr);
      if (result !== 0) throw new Error('Encapsulation failed');
      
      // Read results using getValue (convert signed to unsigned)
      const ciphertext = new Uint8Array(1088);
      const sharedSecret = new Uint8Array(32);
      for (let i = 0; i < 1088; i++) {
        ciphertext[i] = this.module.getValue(ctPtr + i, 'i8') & 0xFF;
      }
      for (let i = 0; i < 32; i++) {
        sharedSecret[i] = this.module.getValue(ssPtr + i, 'i8') & 0xFF;
      }
      
      return { ciphertext, sharedSecret };
    } finally {
      this.module._free(pkPtr);
      this.module._free(ctPtr);
      this.module._free(ssPtr);
    }
  }

  decapsulate(ciphertext, secretKey) {
    if (!this.ready) throw new Error('Module not initialized. Call init() first.');
    if (!(ciphertext instanceof Uint8Array)) throw new Error('Ciphertext must be Uint8Array');
    if (!(secretKey instanceof Uint8Array)) throw new Error('Secret key must be Uint8Array');
    if (ciphertext.length !== 1088) throw new Error('Invalid ciphertext length. Expected 1088 bytes.');
    if (secretKey.length !== 2400) throw new Error('Invalid secret key length. Expected 2400 bytes.');
    
    const ctPtr = this.module._malloc(1088);
    const skPtr = this.module._malloc(2400);
    const ssPtr = this.module._malloc(32);
    
    try {
      // Write input data using writeArrayToMemory
      this.module.writeArrayToMemory(ciphertext, ctPtr);
      this.module.writeArrayToMemory(secretKey, skPtr);
      
      const result = this.module._kyber768_dec(ssPtr, ctPtr, skPtr);
      if (result !== 0) throw new Error('Decapsulation failed');
      
      // Read result using getValue (convert signed to unsigned)
      const sharedSecret = new Uint8Array(32);
      for (let i = 0; i < 32; i++) {
        sharedSecret[i] = this.module.getValue(ssPtr + i, 'i8') & 0xFF;
      }
      return sharedSecret;
    } finally {
      this.module._free(ctPtr);
      this.module._free(skPtr);
      this.module._free(ssPtr);
    }
  }
}

export default Kyber768;
